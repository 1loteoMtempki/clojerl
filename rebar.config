%% Erlang compilation

{ erl_opts
, [ debug_info
  , {platform_define, "^2", 'ETS_CAS'}
  , {platform_define, "^(R|1|20)", 'FUN_STACKTRACE'}
  ]
}.

{src_dirs, ["src", "bootstrap"]}.

%% Clojerl compilation

{clje_src_dirs,  ["src/clj"]}.
{clje_test_dirs, ["test/clj"]}.
{clje_compile_first, ["clojure/core.clje"]}.
{ clje_exclude
, [ "clojure/core_print.clje"
  , "clojure/core_deftype.clje"
  , "clojure/core/protocols.clje"
  , "clojure/instant.clje"
  , "clojure/uuid.clje"

  , "clojure/pprint/cl_format.clje"
  , "clojure/pprint/column_writer.clje"
  , "clojure/pprint/dispatch.clje"
  , "clojure/pprint/pprint_base.clje"
  , "clojure/pprint/pretty_writer.clje"
  , "clojure/pprint/print_table.clje"
  , "clojure/pprint/utilities.clje"
  ]
}.

{ provider_hooks
, [{post, [{compile, {clojerl, compile}}]}]
}.

%% Shell

{shell, [{apps, [clojerl]}]}.

%% Plugins

{ plugins
, [ { rebar3_clojerl
    , {git, "https://github.com/clojerl/rebar3_clojerl", {tag, "0.1.0"}}
    }
  ]
}.

%% Profiles

{ profiles,
  [ { dialyzer
    , [{overrides, [{override, [{provider_hooks, []}]}]}]
    }
  , { dev
    , [ { deps
        , [{eflame, ".*", {git, "https://github.com/jfacorro/eflame", {branch, "various.improvements"}}}]
        }
      ]
    }
  , { test
    , [ {src_dirs, ["src", "bootstrap", "scripts"]}
      , { deps
        , [ {xref_runner, {git, "https://github.com/inaka/xref_runner.git", {tag, "0.2.5"}}}
          , {meck,        {git, "https://github.com/eproxus/meck",          {tag, "0.8.10"}}}
          ]
        }
      ]
    }
  ]
}.

%% Coverage

{cover_enabled, true}.
{ cover_excl_mods
, [ 'clojure.core'
  , 'clojure.core.server'
  , 'clojure.data'
  , 'clojure.erlang.io'
  , 'clojure.instant'
  , 'clojure.main'
  , 'clojure.pprint'
  , 'clojure.repl'
  , 'clojure.set'
  , 'clojure.stacktrace'
  , 'clojure.string'
  , 'clojure.template'
  , 'clojure.test'
  , 'clojure.uuid'
  , 'clojure.walk'
  , 'clojure.xml'
  , 'clojure.zip'

  , 'clojerl.IAssociative'
  , 'clojerl.IColl'
  , 'clojerl.ICounted'
  , 'clojerl.IDeref'
  , 'clojerl.IEquiv'
  , 'clojerl.IHash'
  , 'clojerl.ILookup'
  , 'clojerl.IMap'
  , 'clojerl.IMeta'
  , 'clojerl.IRecord'
  , 'clojerl.IReduce'
  , 'clojerl.ISeqable'
  , 'clojerl.ISequential'
  , 'clojerl.IStringable'
  , 'clojure.core.Eduction'
  , 'clojure.core.protocols'
  , 'clojure.core.protocols.IKVReduce'
  , 'clojure.core.protocols.IKVReduce__clojerl.Map'
  , 'clojure.core.protocols.IKVReduce__clojerl.Nil'
  , 'clojure.core.server.SocketReader'
  , 'clojure.core.server.SocketWriter'
  , 'clojure.data.Diff'
  , 'clojure.data.Diff__clojerl.Default'
  , 'clojure.data.Diff__clojerl.List'
  , 'clojure.data.Diff__clojerl.Map'
  , 'clojure.data.Diff__clojerl.Nil'
  , 'clojure.data.Diff__clojerl.Set'
  , 'clojure.data.Diff__clojerl.SortedMap'
  , 'clojure.data.Diff__clojerl.SortedSet'
  , 'clojure.data.Diff__erlang.List'
  , 'clojure.data.Diff__erlang.Map'
  , 'clojure.data.EqualityPartition'
  , 'clojure.data.EqualityPartition__clojerl.Default'
  , 'clojure.data.EqualityPartition__clojerl.List'
  , 'clojure.data.EqualityPartition__clojerl.Map'
  , 'clojure.data.EqualityPartition__clojerl.Nil'
  , 'clojure.data.EqualityPartition__clojerl.Set'
  , 'clojure.data.EqualityPartition__clojerl.SortedMap'
  , 'clojure.data.EqualityPartition__clojerl.Vector'
  , 'clojure.data.EqualityPartition__erlang.List'
  , 'clojure.data.EqualityPartition__erlang.Map'
  , 'clojure.erlang.io.Coercions'
  , 'clojure.erlang.io.Coercions__clojerl.Nil'
  , 'clojure.erlang.io.Coercions__clojerl.String'
  , 'clojure.erlang.io.Coercions__erlang.io.File'
  , 'clojure.erlang.io.IOFactory'
  , 'clojure.erlang.io.IOFactory__clojerl.Nil'
  , 'clojure.erlang.io.IOFactory__clojerl.String'
  , 'clojure.erlang.io.IOFactory__erlang.io.File'
  , 'clojure.pprint.arg-navigator'
  , 'clojure.pprint.buffer-blob'
  , 'clojure.pprint.CapitalizeWordWriter'
  , 'clojure.pprint.ColumnWriter'
  , 'clojure.pprint.compiled-directive'
  , 'clojure.pprint.DowncaseWriter'
  , 'clojure.pprint.end-block-t'
  , 'clojure.pprint.indent-t'
  , 'clojure.pprint.InitCapWriter'
  , 'clojure.pprint.logical-block'
  , 'clojure.pprint.nl-t'
  , 'clojure.pprint.PrettyFlush'
  , 'clojure.pprint.PrettyWriter'
  , 'clojure.pprint.section'
  , 'clojure.pprint.start-block-t'
  , 'clojure.pprint.UpcaseWriter'
  , 'clojure.repl.PushbackReaderStringWriter'
  , 'clojure.test-clojure.compilation.examples'
  , 'clojure.test-clojure.compilation.examples.T'
  , 'clojure.test-clojure.compilation.examples.X'
  , 'erlang.io.ICloseable'
  , 'erlang.io.IPushbackReader'
  , 'erlang.io.IReader'
  , 'erlang.io.IWriter'
  ]
}.
